# 创建高性能的索引

索引是存储引擎用于快速找到记录的一种数据结构。

索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但是当数据量逐渐增大时，性能则会急剧下降。

索引优化是对查询性能优化最有效的手段。

## 索引的类型

**在Mysql中，索引是在存储引擎层而不是服务器层实现的。** 所以并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

### B-Tree索引

当人们谈论索引的时候，如果没有特别指明类型，那多半说的是`B-Tree`索引，它使用`B-Tree`数据结构来存储数据。大多数存储引擎都支持这种索引。

![](https://github.com/maoyunfei/static-sources/blob/master/mysql_2.png?raw=true)

`B-Tree`通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

`B-Tree`索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。

`B-Tree`对索引列是顺序阻止存储的，所以很适合查找范围数据。

**可以使用B-Tree索引的查询类型**。B-Tree索引适用于全键值、键值范围或前缀查找。其中键前缀查找只适用于根据最左前缀的查找。

#### 全值匹配

全值匹配指的是和索引中的所有列进行匹配。

#### 匹配最左前缀

只匹配索引的第一列。

#### 匹配列前缀

只匹配某一列的值得开头部分。

#### 匹配范围值

#### 精确匹配某一列并范围匹配另一列

#### 只访问索引的查询

因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的`ORDER BY`操作。一般来说，如果`B-Tree`可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果`ORDER BY`子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

#### 下面是关于B-Tree索引的限制

* 如果不是按照索引的最左列开始查找，则无法使用索引。
* 不能跳过索引中的列。
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。

由以上可见，索引列的顺序是多么重要：这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

### 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。

在Mysql中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。

### 全文索引

全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引和其他几类索引的匹配方式完全不一样。它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的`WHERE`条件匹配。

在相同的列上同时创建全文索引和基于值的`B-Tree`索引不会有冲突，全文索引适用于`MATCH AGAINST`操作，而不是普通的`WHERE`条件操作。

## 索引的优点

* 索引大大减少了服务器需要扫描的数据量。
* 索引可以帮助服务器避免排序和临时表。
* 索引可以将随机I/O变为顺序I/O。

## 高性能的索引策略

正确地创建和使用索引是实现高性能查询的基础。

### 独立的列

“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

例如，下面这个查询无法使用`actor_id`列的索引：

```sql
mysql> SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```
下面是另一个常见的错误：

```sql
mysql> SELECT ... WHERE TO_DATS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### 前缀索引和索引选择性

有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。**索引的选择性是指，不重复的索引值和数据表的记录总数(`#T`)的比值，范围从`1/#T`到`1`之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让Mysql在查找时过滤掉更多的行。**唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于`BLOB`、`TEXT`或者很长的`VARCHAR`类型的列，必须使用前缀索引，因为Mysql不允许索引这些列的完整长度。

在city列上创建长度为7的前缀索引：

```sql
mysql> ALTER TABLE sakila.city_demo ADD KEY (city(7))
```

**前缀索引是一种能使索引更小、更快的有效办法。但另一方面也有其缺点：Mysql无法使用前缀索引做`ORDER BY`和`GROUP BY`，也无法使用前缀索引做覆盖扫描。**

### 多列索引

在多个列上建立独立的单列索引大部分情况下并不能提高Mysql的查询性能。Mysql 5.0和更新版本引入了一种叫“索引合并”(index merge)的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。

下面的查询就是使用了两个索引扫描的联合，通过`EXPLAIN`的`Extra`列可以看到这点：

```sql
mysql> EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor

WHERE actor_id = 1 OR film_id = 1
************************ 1. row ******************************
           id: 1
  select_type: SIMPLE
        table: film_actor
         type: index_merge
possible_keys: PRIMARY,idx_fk_film_id
          key: PRIMARY,idx_fk_film_id
      key_len: 2,2
          ref: NULL
         rows: 29
        Extra: Using union(PRIMARY,idx_fk_film_id); Using where
```
Mysql会使用这类技术优化复杂查询，所以某些语句的`Extra`列中还可以看到嵌套操作。

**索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建得很糟糕：**

* 当出现服务器对多个索引做相交操作时(通常有多个`AND`条件)，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
* 当服务器需要对多个索引做联合操作时(通常有多个`OR`条件)，通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。
* 更重要的是，优化器不会把这些计算到“查询成本”中，优化器只关心随机页读取。这会使得查询的成本被低估，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的CPU和内存资源，还可能会影响查询的并发性，但如果是单独运行这样的查询则往往会忽略对并发性的影响。通常来说，还不如将查询改写成`UNION`的方式更好。

如果在`EXPLAIN`中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。也可以通过参数`optimizer_switch`来关闭索引合并功能。也可以使用`IGNORE_INDEX`提示让优化器忽略掉某些索引。

### 选择合适的索引列顺序

正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。

在一个多列`B-Tree`索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的`ORDER BY`、`GROUP BY`和`DISTINCT`等子句的查询需求。所以**多列索引的列顺序至关重要。**

对于如何选择索引的列顺序有一个经验法则：**将选择性最高的列放到索引最前列。**

当不需要排序和分组时，将选择性最高的列放在前面通常是很好的。这时候索引的作用只是用于优化`WHERE`条件的查找。在这种情况下，这样设计的索引确实能够最快地过滤出需要的行，对于在`WHERE`子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性，也和查询条件的具体值有关，也就是和值的分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性更高。

### 聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。

![](https://github.com/maoyunfei/static-sources/blob/master/mysql_3.png?raw=true)

`InnoDB`将通过主键聚集数据，如果没有定义主键，`InnoDB`会选择一个唯一的非空索引代替。如果没有这样的索引，`InnoDB`会隐式定义一个主键来作为聚簇索引。`InnoDB`只聚集在同一个页面中的记录。包含相邻键值得页面可能会相距甚远。

**聚簇索引的优点：**

* 可以把相关数据保存在一起。
* 数据访问更快。
* 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

**聚簇索引的缺点：**

* 聚簇索引最大限度地提高了`I/O`密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。
* 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到`InnoDB`表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用`OPTIMIZE TABLE`命令重新组织一下表。
* 更新聚簇索引列的代价很高，因为会强制`InnoDB`将每个被更新的行移动到新的位置。
* 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行时，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间。
* 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
* 二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。
* 二级索引访问需要两次索引查找，而不是一次。

### 覆盖索引

如果一个索引包含(或者说覆盖)所有需要查询的字段的值，我们就称之为“覆盖索引”。

不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引列的值，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以Mysql只能使用`B-Tree`索引做覆盖索引。

### 使用索引扫描来做排序

Mysql有两种方式可以生成有序的结果：通过排序操作；或者按索引顺序扫描；如果`EXPLAIN`出来的`type`列的值为`"index"`，则说明Mysql使用了索引扫描来做排序。

扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机`I/O`，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在`I/O`密集型的工作负载时。

Mysql可以使用同一个索引既满足排序，有用于查找。

**只有当索引的列顺序和`ORDER BY`子句的顺序完全一致，并且所有列的排序方向(倒序或正序)都一样时，Mysql才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当`ORDER BY`子句引用的字段全部为第一个表时，才能使用索引做排序。`ORDER BY`子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则Mysql都需要执行排序操作，而无法利用索引排序。**

**有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。**

### 索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。首先，虽然`InnoDB`的行锁效率很高，内存使用也很少，但是锁定行的时候仍然会带来额外开销；其次，锁定超过需要的行会增加锁争用并减少并发性。





